/**
 * @author wItspirit
 * 6-feb-2005
 * NormalizedCsvImporter.java
 */

package be.vanvlerken.bert.zfpricemgt.database.importers;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.text.ParseException;
import java.util.Date;
import java.util.Locale;
import java.util.ResourceBundle;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import be.vanvlerken.bert.zfpricemgt.IProduct;
import be.vanvlerken.bert.zfpricemgt.database.Product;

/**
 * Imports the normalized CSV format as generated by the Text2Csv application.
 * It is also the format normally read by the ZF Data Insertion application
 */
public class NormalizedCsvImporter implements Importer
{
    private static final ResourceBundle msgs = ResourceBundle.getBundle("be.vanvlerken.bert.zfpricemgt.database.importers.localization.NormalizedCsvImporter");
    private static final ResourceBundle commonErrors = ResourceBundle.getBundle("be.vanvlerken.bert.zfpricemgt.database.importers.localization.ImporterErrorConditions");
    private static final DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT, Locale.FRANCE);
    private static final Log log = LogFactory.getLog(NormalizedCsvImporter.class);
    
    private final Pattern detectPattern;
    private final Pattern parsePattern;
    
    private BufferedReader reader;
    private Date validSince;
    private boolean overruleValidSince;
       
    public NormalizedCsvImporter()
    {
        detectPattern = Pattern.compile("^.{1,20},[^,]{0,100},\\d*\\.?\\d*(,\\d{2}/\\d{2}/\\d{2,4})?$");
        parsePattern = Pattern.compile("^(.{1,20}),([^,]{0,100}),(\\d*\\.?\\d*)(,(\\d{2}/\\d{2}/\\d{2,4}))?$");
    }
    
    /**
     * @see be.vanvlerken.bert.zfpricemgt.database.importers.Importer#canImport(java.io.InputStream)
     */
    public boolean canImport(InputStream is)
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(is));

        String line;
        try
        {
            line = reader.readLine();
        }
        catch (IOException e)
        {
            return false;
        }

        return detectPattern.matcher(line).matches();
    }

    public String toString()
    {
        return msgs.getString("description");
    }

    public void startImport(InputStream is, Date validSince, boolean overruleValidSince)
    {
        reader = new BufferedReader(new InputStreamReader(is));
        this.validSince = validSince;
        this.overruleValidSince = overruleValidSince;
    }

    public IProduct nextProduct()
    {
        String line;
        try
        {
            line = reader.readLine();
            while (line != null)
            {
                Date productValidSince = validSince;
                Matcher matcher = parsePattern.matcher(line);
                if (matcher.find())
                {
                    String productId = matcher.group(1);
                    String productDescription = matcher.group(2);
                    double price = Double.parseDouble(matcher.group(3));
                    String validSinceStr = matcher.group(5);
                    if ( validSinceStr != null && !validSinceStr.equals("") && !overruleValidSince)
                    {
                        // We have a validSince date in the import file and we should use it !
                        try
                        {
                            Date importValidSince = df.parse(validSinceStr);
                            productValidSince = importValidSince;
                        }
                        catch (ParseException e)
                        {
                            log.warn("Could not parse validSinceStr ("+validSinceStr+") as a valid date according to DD/MM/YYYY");
                            log.warn("Reverting to provided validSince ("+df.format(productValidSince)+")");
                        }
                    }

                    return new Product(productId, productDescription, price, productValidSince);
                }
                else
                {
                    log.warn(MessageFormat.format(commonErrors.getString("could.not.parse"), line));
                }
                // Read the next line
                line = reader.readLine();
            }
        }
        catch (IOException e)
        {
            // Ignore...
            log.error("Received an IOException while reading from "+reader, e);
            log.error("Aborting import (could be the result of a cancel operation !");
        }
        return null;
    }

    public void stopImport()
    {
        reader = null;
        validSince = null;
    }
}
